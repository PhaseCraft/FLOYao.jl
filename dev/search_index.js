var documenterSearchIndex = {"docs":
[{"location":"features/features/#Features","page":"Features","title":"Features","text":"","category":"section"},{"location":"features/features/","page":"Features","title":"Features","text":"The core part of FLOYao is the a new register type, the MajoranaReg:","category":"page"},{"location":"features/features/","page":"Features","title":"Features","text":"MajoranaReg","category":"page"},{"location":"features/features/#FLOYao.MajoranaReg","page":"Features","title":"FLOYao.MajoranaReg","text":"MajoranaReg{T} <: AbstractRegister{2}\nMajoranaReg(state::AbstractMatrix{T<:Real})\n\nA register holding the \"state\" of a Majorana operators when propagating through a FLO circuit as a 2n×2n matrix.\n\nWarning\n\nThe MajoranaReg constructor will not initialize the state matrix. It is  recommended to use FLOYao.zero_state or FLOYao.product_state to produce your initial state.\n\n\n\n\n\n","category":"type"},{"location":"features/features/#State-initialization","page":"Features","title":"State initialization","text":"","category":"section"},{"location":"features/features/","page":"Features","title":"Features","text":"There are several functions provided, to create MajoranaReg's  in different states. They are not exported from FLOYao.jl in order to avoid name collisions with Yao.jl","category":"page"},{"location":"features/features/","page":"Features","title":"Features","text":"FLOYao.zero_state\nFLOYao.zero_state_like\nFLOYao.one_state\nFLOYao.product_state","category":"page"},{"location":"features/features/#FLOYao.zero_state","page":"Features","title":"FLOYao.zero_state","text":"zero_state([T=Float64,] n)\n\nCreate a Majorana register on n qubits in the vacuum state Ω with storage type T.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.zero_state_like","page":"Features","title":"FLOYao.zero_state_like","text":"zero_state_like(reg::AbstractRegister)\n\nCreate a Majorana register in the zero state with the same element type  and number of qubits as reg.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.one_state","page":"Features","title":"FLOYao.one_state","text":"one_state([T=Float64,] n)\n\nCreate a Majorana register on n qubits in the all one state 1  1 with storage type T.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.product_state","page":"Features","title":"FLOYao.product_state","text":"product_state([T=Float64,] bit_str::DitStr{2})\nproduct_state([T=Float64,] bit_configs::AbstractVector)\nproduct_state([T=Float64,] nbits::Int, val::Int)\n\nCreate an MajoranaReg of a product state.\n\nThe state can be specified as a bit string, as an array of Integers or Booleans or with nbits and val.\n\n\n\n\n\n","category":"function"},{"location":"features/features/","page":"Features","title":"Features","text":"as well as some functions to reset MajoranaReg's to fixed states:","category":"page"},{"location":"features/features/","page":"Features","title":"Features","text":"FLOYao.zero_state!\nFLOYao.one_state!\nFLOYao.product_state!","category":"page"},{"location":"features/features/#FLOYao.zero_state!","page":"Features","title":"FLOYao.zero_state!","text":"zero_state!(reg::MajoranaReg)\n\nPut reg into the computational zero state\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.one_state!","page":"Features","title":"FLOYao.one_state!","text":"one_state!(reg::MajoranaReg)\n\nPut reg into the all ones state\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.product_state!","page":"Features","title":"FLOYao.product_state!","text":"product_state!(reg::MajoranaReg, bit_str::BitStr)\n\nPut reg into the product state described by bit_str\n\n\n\n\n\n","category":"function"},{"location":"features/features/#Applying-gates","page":"Features","title":"Applying gates","text":"","category":"section"},{"location":"features/features/","page":"Features","title":"Features","text":"Application of Supported gates to MajoranaReg's works  as it does in Yao.jl","category":"page"},{"location":"features/features/","page":"Features","title":"Features","text":"YaoAPI.apply! ","category":"page"},{"location":"features/features/#YaoAPI.apply!","page":"Features","title":"YaoAPI.apply!","text":"apply!(register, block)\n\nApply a block (of quantum circuit) to a quantum register.\n\nnote: Note\nto overload apply! for a new block, please overload the unsafe_apply! function with same interface. Then the apply! interface will do the size checks on inputs automatically.\n\nExamples\n\njulia> r = zero_state(2)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 2/2\n    nlevel: 2\n\njulia> apply!(r, put(2, 1=>X))\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 2/2\n    nlevel: 2\n\njulia> measure(r;nshots=10)\n10-element Vector{DitStr{2, 2, Int64}}:\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n\n\n\n\n\n","category":"function"},{"location":"features/features/#Measuring-expectation-values","page":"Features","title":"Measuring expectation values","text":"","category":"section"},{"location":"features/features/","page":"Features","title":"Features","text":"The same goes measuring expectation values ","category":"page"},{"location":"features/features/","page":"Features","title":"Features","text":"expect ","category":"page"},{"location":"features/features/#YaoAPI.expect","page":"Features","title":"YaoAPI.expect","text":"expect(op::AbstractBlock, reg) -> Vector\nexpect(op::AbstractBlock, reg => circuit) -> Vector\nexpect(op::AbstractBlock, density_matrix) -> Vector\n\nGet the expectation value of an operator, the second parameter can be a register reg or a pair of input register and circuit reg => circuit.\n\nexpect'(op::AbstractBlock, reg=>circuit) -> Pair\nexpect'(op::AbstractBlock, reg) -> AbstracRegister\n\nObtain the gradient with respect to registers and circuit parameters. For pair input, the second return value is a pair of gψ=>gparams, with gψ the gradient of input state and gparams the gradients of circuit parameters. For register input, the return value is a register.\n\nnote: Note\nFor batched register, expect(op, reg=>circuit) returns a vector of size number of batch as output. However, one can not differentiate over a vector loss, so expect'(op, reg=>circuit) accumulates the gradient over batch, rather than returning a batched gradient of parameters.\n\nExamples\n\njulia> r = normalize!(product_state(bit\"11\") + product_state(bit\"00\"))\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 2/2\n    nlevel: 2\n\njulia> op = chain(2, put(1=>H), put(2=>X))\nnqubits: 2\nchain\n├─ put on (1)\n│  └─ H\n└─ put on (2)\n   └─ X\n\n\njulia> expect(op, r)\n0.7071067811865474 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"features/features/","page":"Features","title":"Features","text":"where (for now) op is restricted to be an observable quadratic in the  Majorana operators (see Known restrictions).","category":"page"},{"location":"features/features/#Sampling","page":"Features","title":"Sampling","text":"","category":"section"},{"location":"features/features/","page":"Features","title":"Features","text":"Samples in the computational basis can be obtained with the same functions as  in Yao.jl:","category":"page"},{"location":"features/features/","page":"Features","title":"Features","text":"measure(::MajoranaReg)\nmeasure!(::MajoranaReg)","category":"page"},{"location":"features/features/#YaoAPI.measure-Tuple{MajoranaReg}","page":"Features","title":"YaoAPI.measure","text":"measure(reg::MajoranaReg[, locs]; nshots=1, rng=Random.GLOBAL_RNG) -> Vector{BitStr}\n\nMeasure a MajoranaReg and return the results as a vector of BitStrings. This is a cheating version of measure! that does not need to recompute the reg  for each new sample and also does not alter it.\n\nArguments\n\nreg::MajoranaReg: The state register\nlocs: The list of qubits to measure. Defaults to all qubits.\nnshots=1: The number of samples to take\nrng=Random.GLOBAL_RNG: The random number generator to use\n\n\n\n\n\n","category":"method"},{"location":"features/features/#YaoAPI.measure!-Tuple{MajoranaReg}","page":"Features","title":"YaoAPI.measure!","text":"measure!([postprocess::Union{NoPostProcess, ResetTo},] reg::MajoranaReg; rng=Random.GLOBAL_RNG)\n\nMeasure a Majorana register in the computational basis and return the  resulting BitStr.\n\nArguments\n\npostprocess: Is the post processing method\nNoPostProcess() (the default) will collapse the state to the measurement                   outcome state.\nResetTo(bit_str) will reset the state to the product state specified by                     bit_str\nreg::MajoranaReg: The quantum register\nrng::Random.GLOBAL_RNG: The RNG to use\n\n\n\n\n\n","category":"method"},{"location":"features/features/#Non-exported-functions","page":"Features","title":"Non-exported functions","text":"","category":"section"},{"location":"features/features/","page":"Features","title":"Features","text":"The following functions are not exported and not really needed for the  functionality of FLOYao, but can be useful for debugging.","category":"page"},{"location":"features/features/","page":"Features","title":"Features","text":"FLOYao.paulibasis2qubitop\nFLOYao.majoranasquares2qubitbasis\nFLOYao.qubit2paulibasis\nFLOYao.qubit2majoranaevolution\nFLOYao.paulibasis2majoranasquares\nFLOYao.yaoham2majoranasquares\nFLOYao.majorana2arrayreg","category":"page"},{"location":"features/features/#FLOYao.paulibasis2qubitop","page":"Features","title":"FLOYao.paulibasis2qubitop","text":"paulibasis2qubitop(P::AbstractVector)\n\nConverts an operator to in the pauli basis to a matrix in the computational basis. Inverse to qubit2paulibasis.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.majoranasquares2qubitbasis","page":"Features","title":"FLOYao.majoranasquares2qubitbasis","text":"majoranasquares2qubitbasis(H::AbstractMatrix)\n\nConverts an 2n2n Majorana hamiltonian H into the full 2^n2^n hamiltonian in the qubit basis.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.qubit2paulibasis","page":"Features","title":"FLOYao.qubit2paulibasis","text":"qubit2paulibasis(A::AbstractMatrix)\n\nConverts a 2^n2^n matrix A in the standard qubit basis into a  4^n vector representing the same operator in the Pauli basis.\n\nThe ordering is as follows: Let σ^0 = I σ^1 = X σ^2 = Y and σ^3 = Z. \n\nTodo\n\nCreating the dense pauli tensor product via kron and inner product via dot is much slower than neccessary, since the pauli tensor product matrix is  very sparse. Much faster would be to compute the inner product directly.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.qubit2majoranaevolution","page":"Features","title":"FLOYao.qubit2majoranaevolution","text":"qubit2majoranaevolution(U::AbstractMatrix, locs)\n\nTurns a n qubit unitary U on the n qubits in locs into the corresponding SO(2n2n) matrix for the evolution of the Majorana operators.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.paulibasis2majoranasquares","page":"Features","title":"FLOYao.paulibasis2majoranasquares","text":"paulibasis2majoranasquares(P::AbstractVector, locs=1:log4(length(P)))\n\nConvert an operator written in the Pauli basis as a 4^n-element vector to the corresponding 2n2n matrix of coefficients of products of two Majorana operators.\n\nThrows a NonFLOException if P contains terms that are not corresponding to  the product of two Majorana operators.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.yaoham2majoranasquares","page":"Features","title":"FLOYao.yaoham2majoranasquares","text":"yaoham2majoranasquares(::Type{T}=Float64, yaoham::AbstracBlock{2})\n\nConvert a hamiltonian written as a YaoBlock into the corresponding  2n2n majorana hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.majorana2arrayreg","page":"Features","title":"FLOYao.majorana2arrayreg","text":"majorana2arrayreg(reg::MajoranaReg)\n\nConverts a 2n×2n MajoranaReg reg into a 2^n ArrayReg.\n\nNote\n\nThis implementation is not very clever and should mainly be used for debugging purposes with small numbers of qubits. If ΩUΩ is close to zero, it is not very accurate.\n\n\n\n\n\n","category":"function"},{"location":"vqe_example/#Example:-VQE-for-the-transverse-field-Ising-model","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"","category":"section"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"One prime example of a free fermion Hamiltonian and FLO circuit is  the variational quantum eigensolver with the hamiltonian variational ansatz  applied  the transverse field Ising model. It is a good example demonstrating the capabilities of FLOYao.","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"The Hamiltonian is given as ","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"    H = J _i^L-1 X_i X_i+1 + h _i^L Z_i = U + T","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"and as Ansatz circuits we use the Hamiltonian Variational Ansatz","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"    U(vec θ) = _i^p e^-iθ_iU U e^-iθ_iT T ","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"with the initial state being the groundstate of the TFIM at J = 0, so ψ_i = 0  0.","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"First, we define the Hamiltonian","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"using FLOYao, Yao\nL = 100 # this is far beyond what is possible with a full wavefunction simulation\nJ = 1.5 \nh = -1.\np = 10  # number of VQE layers\nU = map(1:L-1) do i\n    J * kron(L, i => X, i+1 => X)\nend |> sum\n\nT = map(1:L) do i\n    h * kron(L, i => Z)\nend |> sum\n\nhamiltonian = T + U\n# not really needed, but here to circumvent some doctest  restrictions\nsummary(hamiltonian)\n\n# output\n\"Add{2}\"","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"and the ansatz circuit","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"circuit = chain(L)\nfor _ in 1:p\n    for i in 1:L-1\n        push!(circuit, rot(kron(L, i => X, i+1 => X), 0.))\n    end\n    for i in 1:L\n        push!(circuit, put(L, i => Rz(0.)))\n    end\nend\n\n# output","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"as well as the initial state","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"reg = FLOYao.zero_state(L)\ntypeof(reg)\n\n# output\nMajoranaReg{Float64}","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"Now that we defined the hamiltonian, the ansatz circuit and the initial state we can perform simple gradient descent on the energy expectation value to find an approximation to the groundstate of H:","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"iterations = 100\ngamma = 2e-2\n\n# set the initial parameters\nnparams = nparameters(circuit)\ndispatch!(circuit, ones(nparams) ./ 100) # fix initial parameters for reproducibility\n\nfor i in 1:iterations\n    _, grad = expect'(hamiltonian, reg => circuit)\n    dispatch!(-, circuit, gamma * grad)\n    println(\"Iteration $i, energy = $(round(expect(hamiltonian, reg => circuit), digits=4))\")\nend\n\n# output\nIteration 1, energy = -99.7577\nIteration 2, energy = -100.1858\nIteration 3, energy = -100.3843\nIteration 4, energy = -100.6364\nIteration 5, energy = -101.0342\nIteration 6, energy = -101.6735\nIteration 7, energy = -102.6934\nIteration 8, energy = -104.2918\nIteration 9, energy = -106.7225\nIteration 10, energy = -110.2443\nIteration 11, energy = -114.983\nIteration 12, energy = -120.7112\nIteration 13, energy = -126.7071\nIteration 14, energy = -131.975\nIteration 15, energy = -135.8116\nIteration 16, energy = -138.1614\nIteration 17, energy = -139.4181\nIteration 18, energy = -140.0345\nIteration 19, energy = -140.3264\nIteration 20, energy = -140.4677\nIteration 21, energy = -140.5422\nIteration 22, energy = -140.5877\nIteration 23, energy = -140.6206\nIteration 24, energy = -140.648\nIteration 25, energy = -140.6729\nIteration 26, energy = -140.6966\nIteration 27, energy = -140.7196\nIteration 28, energy = -140.7423\nIteration 29, energy = -140.7647\nIteration 30, energy = -140.7869\nIteration 31, energy = -140.809\nIteration 32, energy = -140.831\nIteration 33, energy = -140.8529\nIteration 34, energy = -140.8747\nIteration 35, energy = -140.8965\nIteration 36, energy = -140.9182\nIteration 37, energy = -140.9398\nIteration 38, energy = -140.9614\nIteration 39, energy = -140.983\nIteration 40, energy = -141.0045\nIteration 41, energy = -141.026\nIteration 42, energy = -141.0475\nIteration 43, energy = -141.0689\nIteration 44, energy = -141.0904\nIteration 45, energy = -141.1118\nIteration 46, energy = -141.1332\nIteration 47, energy = -141.1545\nIteration 48, energy = -141.1759\nIteration 49, energy = -141.1973\nIteration 50, energy = -141.2187\nIteration 51, energy = -141.24\nIteration 52, energy = -141.2614\nIteration 53, energy = -141.2828\nIteration 54, energy = -141.3042\nIteration 55, energy = -141.3256\nIteration 56, energy = -141.347\nIteration 57, energy = -141.3685\nIteration 58, energy = -141.3899\nIteration 59, energy = -141.4114\nIteration 60, energy = -141.4329\nIteration 61, energy = -141.4544\nIteration 62, energy = -141.476\nIteration 63, energy = -141.4976\nIteration 64, energy = -141.5193\nIteration 65, energy = -141.5409\nIteration 66, energy = -141.5627\nIteration 67, energy = -141.5844\nIteration 68, energy = -141.6062\nIteration 69, energy = -141.6281\nIteration 70, energy = -141.65\nIteration 71, energy = -141.672\nIteration 72, energy = -141.694\nIteration 73, energy = -141.7161\nIteration 74, energy = -141.7383\nIteration 75, energy = -141.7605\nIteration 76, energy = -141.7829\nIteration 77, energy = -141.8052\nIteration 78, energy = -141.8277\nIteration 79, energy = -141.8503\nIteration 80, energy = -141.8729\nIteration 81, energy = -141.8956\nIteration 82, energy = -141.9184\nIteration 83, energy = -141.9414\nIteration 84, energy = -141.9644\nIteration 85, energy = -141.9875\nIteration 86, energy = -142.0107\nIteration 87, energy = -142.0341\nIteration 88, energy = -142.0576\nIteration 89, energy = -142.0812\nIteration 90, energy = -142.1049\nIteration 91, energy = -142.1287\nIteration 92, energy = -142.1527\nIteration 93, energy = -142.1768\nIteration 94, energy = -142.2011\nIteration 95, energy = -142.2255\nIteration 96, energy = -142.25\nIteration 97, energy = -142.2748\nIteration 98, energy = -142.2997\nIteration 99, energy = -142.3247\nIteration 100, energy = -142.3499","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"Hopefully, this is a good enough approximation to the groundstate. We can now  use this to sample from the state we found:","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the transverse field Ising model","title":"Example: VQE for the transverse field Ising model","text":"using Random\nsamples = measure(reg |> circuit, nshots=10, rng=MersenneTwister(42))\n\n# output\n\n10-element Vector{DitStr{2, 100, BigInt}}:\n 0000000000000000000000000000000000000000000000000011000000000000000000000101000000000000111100110000 ₍₂₎\n 0000000000000000000000000000000000000000000000000000000000000000000000000011011001100000000000000000 ₍₂₎\n 0000000000000000000000000000000000000000000000011000000000001100000000110000000000001100000110000000 ₍₂₎\n 0000000000000000000000000000000000000011000000011000000000000110000000000011000000000000000011000011 ₍₂₎\n 0000000000000000000000000000000000000000000000000000000000000000000001100000000000011111100000000000 ₍₂₎\n 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011000011 ₍₂₎\n 0000000000000000000000000000000000000000000000001010000000101000000000000000000000011000000000000000 ₍₂₎\n 0000000000000000000000000000000000000000000000000000000001100000000000000000000000000001100000000000 ₍₂₎\n 0000000000000000000000000000000000000000000000000000110000000010100000000001100000000000000011110000 ₍₂₎\n 0000000000000000000000000000000000000110000000000010001000000000110000000000001100000011011000000000 ₍₂₎","category":"page"},{"location":"features/supported_gates/#Supported-gates","page":"Supported Gates","title":"Supported gates","text":"","category":"section"},{"location":"features/supported_gates/","page":"Supported Gates","title":"Supported Gates","text":"The following gates are FLO gates and supported by FLOYao.jl:","category":"page"},{"location":"features/supported_gates/","page":"Supported Gates","title":"Supported Gates","text":"Gate Comment\nXGate Together with Y the only gate that does not preserve fermionic parity\nYGate See above\nZGate \nRotationGate{⋯,⋯,ZGate} The only single qubit rotation gate since R_x(θ)γ_i R_x(-θ) is not a linear combination of Majorana operators for all Majorana operators. Similar for R_y\nPauliKronBlock A kronecker product of Pauli operators s.t. that first and last operator are either X or Y and all operators in between are Z.\nRotationGate{⋯,⋯,PauliKronBlock} A rotation gate with generator as in the last line.\nAbstractMatrix Unless the gate type is already explicitely implemented or know to not be a FLO gate, FLOYao will try to automatically convert the gate matrix in the qubit basis to a matrix in the Majorana basis. But note that this is fairly slow (although still poly-time instead of exp-time)","category":"page"},{"location":"features/supported_gates/","page":"Supported Gates","title":"Supported Gates","text":"If you want to add support to your own gates, read Adding support for custom gates to learn how to do that.","category":"page"},{"location":"known_restrictions/#Known-restrictions","page":"Known restrictions","title":"Known restrictions","text":"","category":"section"},{"location":"known_restrictions/#Expectation-values-of-higher-order-observables","page":"Known restrictions","title":"Expectation values of higher order observables","text":"","category":"section"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"So far, FLOYao only supports expectation values of observables that are sums of squares of  Majorana operators. But in general, one can use Wick's theorem to calculate the expectation values of expressions of the form ","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"    O = Omega U^ O UOmega ","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"where Ω = 0  0 is the all zero stat, O a string of Majorana operators and U a FLO unitary. Thus, using linearity of the expectation value, it is possible to efficiently calculate the expectation value of any observable that can be expanded in a sum of polynomially (in the number of qubits) many products of Majorana operators. (See also Classical simulation of noninteracting-fermion quantum circuits again for details). If you need expectation values of higher order (in the number of Majorana operators involved) observables, feel free to open a pull request!","category":"page"},{"location":"known_restrictions/#\"Hidden\"-FLO-circuits","page":"Known restrictions","title":"\"Hidden\" FLO circuits","text":"","category":"section"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"Yao.jl allows to express the same circuit in different forms. E.g. ","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"chain(nq, put(1 => X), put(2 => X))","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"and","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"kron(nq, 1 => X, 2 => X)","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"represent the same FLO circuit, but only the latter will be recognised as such. Similarly ","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"kron(nq, 1 => X, 2 => X, 3 => X, 4 => X)","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"and","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"chain(nq, kron(1 => X, 2 => X), kron(3 => X, 4 => X))","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"represent the same FLO circuit but only the latter will be recognised as such. This is because","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"We don't check if a whole ChainBlock is a FLO circuit, even if its single gates are not. Instead a ChainBlock is applied gate by gate, each of which has to be a FLO gate.\nFor KronBlocks we first try if each factor is a FLO gate and then if the whole block altogether is of the form  kron(nq, i => σ1, i+1 => Z, ⋯, i-1 => Z, j => σ2) with σ1, σ2 ∈ [X, Y].","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"If you run into a case that is a FLO circuit / gate but not recognised as such please open an issue or even pull request.","category":"page"},{"location":"background/#background","page":"Mathematical Background","title":"Mathematical Background","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"This section is here, more to fix the convention of Jordan-Wigner transform and Majorana operators that we use here, and less to explain the full theory behind those. For the latter, we, once again, recommend Classical simulation of noninteracting-fermion quantum circuits.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"We define the Majorana operators γ_i via ","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"    γ_2i-1 = _j=1^i-1 (-Z_j) X_i\n    qquad textrmand qquad\n    γ_2i = -_j=1^i-1 (-Z_j) Y_i","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"This implies the normal fermionic creation and annihilation operators are given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"    c_j = frac12 (γ_2j-1 + iγ_2j)\n    quad textrmand quad\n    c_j^ = frac12 (γ_2j-1 - iγ_2j)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"and products of two Majorana operators are of the form","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"    σ_i left(_ijk Z_k right) σ_k\n    quad textrmor quad\n    Z_i","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"with σ_i σ_k  X Y.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Any unitary that takes all Majorana operators to a linear combination of Majorana operators under conjugation, i.e. that satisfies","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"    U γ_i U^ = R_i^j γ_j","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"with some R  O(2n) is a FLO unitary. In particular, if a unitary is of the form ","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"    U = e^-iθH","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"with ","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"    H = fraci4 sum_ij H^ij γ_i γ_j","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"it is a FLO unitary with R  SO(2n).","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"But note, that not all FLO unitaries are of that form. For example X_i is also a FLO  gate since it either commutes or anti-commutes with all Majorana operators, but the associated matrix R always has determinant -1.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Calculating the expectation values of hamiltonians like the one above when evolving the  vacuum state with FLO circuits is efficiently possible. First evolve the  Hamiltonian in the Heisenber picture to","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"    UHU^ = fraci4 R^m_i R^n_j H^ij γ_m γ_n \n           = fraci4 tilde H^mn γ_m γ_n","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"and then compute the expectation value","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"beginaligned\n    ψUHU^ψ = fraci4 tilde H^mn Ωγ_m γ_nΩ \n                = - frac12 _i tilde H^2i-12i \n                = - frac12 _i R^2i-1_m R^2i_n H^mn \nendaligned","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"From the first to second line one needs to carefully think which of the  Ωγ_m γ_nΩ are zero and which cancel each other out due to the anti-symmetry of H^mn.","category":"page"},{"location":"#FLOYao","page":"Home","title":"FLOYao","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Yao.jl backend to efficiently simulated fermionic linear optics (FLO) circuits in  based on Classical simulation of noninteracting-fermion quantum circuits and Disorder-assisted error correction in Majorana chains. FLO circuits are a class of quantum circuits that are closely related to non-interacting fermions and can be efficiently simulated on classical computers, similar to the way Clifford circuits can be efficiently classically simulated, as is done in YaoClifford.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A quick introduction to fermionic linear optics circuits is found in Background section and a more in-depth introduction in e.g. the two papers linked above.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FLOYao can be simply installed from the REPL via","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add FLOYao","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First import FLOYao and Yao","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FLOYao, Yao\n\n# output","category":"page"},{"location":"","page":"Home","title":"Home","text":"then build a (here somewhat arbitrary) circuit consisting only of Supported gates","category":"page"},{"location":"","page":"Home","title":"Home","text":"nq = 4\nθ = π/8\ncircuit = chain(nq)\n\npush!(circuit, put(nq, 3=>Rz(0.5)))\n\nxxg1 = kron(nq, 1 => X, 2 => X)\nrg = rot(xxg1, θ)\npush!(circuit, rg)  \n\nxxg2 = kron(nq, 2 => X, 3 => Z, 4 => X)\nrg = rot(xxg2, θ)\npush!(circuit, rg)  \npush!(circuit, put(nq, 3=>Rz(0.5)))\npush!(circuit, put(nq, 1=>Z))\n\nxxg3 = kron(nq, 2 => X, 3 => X)\nrg = rot(xxg3, θ)\n\ncircuit","category":"page"},{"location":"","page":"Home","title":"Home","text":"and define an observable that is a sum of squares of Majorana operators","category":"page"},{"location":"","page":"Home","title":"Home","text":"hamiltonian = xxg1 + xxg2 + xxg3 + kron(nq, 2=>Z) + kron(nq, 3=>Z)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and finally create a register in the computational zero state via","category":"page"},{"location":"","page":"Home","title":"Home","text":"reg = FLOYao.zero_state(nq)\n\n# output\nMajoranaReg{Float64} with 4 qubits:\n8×8 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Applying the circuit to the register works then exactly the same way as for a normal ArrayReg register:","category":"page"},{"location":"","page":"Home","title":"Home","text":"apply(reg, circuit)\n\n# output\nMajoranaReg{Float64} with 4 qubits:\n8×8 Matrix{Float64}:\n -1.0  -0.0       -0.0       -0.0       -0.0       -0.0       -0.0       -0.0\n -0.0  -0.92388    0.382683  -0.0       -0.0       -0.0       -0.0       -0.0\n  0.0   0.382683   0.92388    0.0        0.0        0.0        0.0        0.0\n  0.0   0.0        0.0        0.92388    0.0        0.0        0.382683   0.0\n  0.0   0.0        0.0        0.0        0.540302   0.841471   0.0        0.0\n  0.0   0.0        0.0        0.0       -0.841471   0.540302   0.0        0.0\n  0.0   0.0        0.0       -0.382683   0.0        0.0        0.92388    0.0\n  0.0   0.0        0.0        0.0        0.0        0.0        0.0        1.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"and the same goes for expectation values of observables","category":"page"},{"location":"","page":"Home","title":"Home","text":"expect(hamiltonian, reg => circuit)\n\n# output\n1.8535533905932737","category":"page"},{"location":"","page":"Home","title":"Home","text":"or even gradients of these expectation values with respect to the circuit parameters","category":"page"},{"location":"","page":"Home","title":"Home","text":"state_grad, params_grad = expect'(hamiltonian, reg => circuit)\n\n# output\nMajoranaReg{Float64}(4) => [0.0, -0.3535533905932738, -0.3535533905932738, 0.0]","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"vqe_example.md\",\n    \"features/features.md\",\n    \"features/supported_gates.md\",\n    \"background.md\",\n    \"adding_gates.md\",\n    \"known_restrictions.md\"\n]","category":"page"},{"location":"adding_gates/#Adding-support-for-custom-gates","page":"Adding custom gates","title":"Adding support for custom gates","text":"","category":"section"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"Natively, the only FLO gates that come already shipped with FLOYao.jl are these Supported gates. But there are many more FLO gates, one being for example the FSWAP gate which swaps to qubits while making sure to preserve the fermionic commutation relations","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"@const_gate FSWAP::ComplexF64 = [1 0 0 0; 0 0 1 0; 0 1 0 0; 0 0 0 -1]","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"If a gate defines a matrix representation, as we just did for the FSWAPgate, FLOYao supports them out of the box by manually checking if they are a FLO gate and then computing its matrix representation in the Majorana basis. But this method is fairly slow–-though still poly-time and memory–-compared to directly implementing unsafe_apply!(::MajoranaReg, ::YourBlock) and instruct!(::MajoranaReg, ::YourBlock) and will warn you accordingly:","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"nq = 4\nfswap = put(nq, (1, 2) => FSWAP)\nmreg = FLOYao.zero_state(nq)\nmreg |> put(nq, 2 => X)\nmreg |> fswap","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"┌ Warning: Calling manual instruct!(MajoranaReg{Float64}(4), ComplexF64[1.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im 1.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im -1.0 + 0.0im], (1, 2)).\n│ You can greatly speed up your FLO gates by exactly implementing unsafe_apply!()\n│ and instruct!() for them. See FLOYao/src/instruct.jl and  FLOYao/src/apply_composite.jl\n│ for how to do that.\n└ @ FLOYao ~/.julia/.../FLOYao/src/instruct.jl:56\n\nMajoranaReg{Float64} with 4 qubits:\n8×8 Matrix{Float64}:\n -2.35415e-16  -4.12493e-16  -1.0          …   0.0   0.0   0.0   0.0\n  2.46746e-16  -5.5708e-16   -1.26504e-16      0.0   0.0   0.0   0.0\n -1.0          -1.17708e-16   2.55988e-16      0.0   0.0   0.0   0.0\n -1.85286e-16  -1.0           2.44068e-16      0.0   0.0   0.0   0.0\n -0.0          -0.0          -0.0             -1.0  -0.0  -0.0  -0.0\n -0.0          -0.0          -0.0          …  -0.0  -1.0  -0.0  -0.0\n -0.0          -0.0          -0.0             -0.0  -0.0  -1.0  -0.0\n -0.0          -0.0          -0.0             -0.0  -0.0  -0.0  -1.0","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"Now, before we fix these warnings, let's see how long the current implementation takes:","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"using BenchmarkTools\nusing Suppressor # we don't want to get all the warnings when benchmarking\n@benchmark @suppress apply!($mreg, $fswap)","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"BenchmarkTools.Trial: 6524 samples with 1 evaluation.\n Range (min … max):  707.996 μs …   3.773 ms  ┊ GC (min … max): 0.00% … 73.67%\n Time  (median):     727.015 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   761.750 μs ± 225.610 μs  ┊ GC (mean ± σ):  2.31% ±  6.25%\n\n  ▆█▇▆▅▄▄▄▃▃▂▂▁▁                                                ▂\n  ███████████████▇██▇▇▃▅▅▄▅▅▄▃▄▁▃▃▁▁▃▃▃▃▁▃▁▃▁▁▁▃▁▄▁▁▁▃▃▆▆▆▆▆▆▄▄ █\n  708 μs        Histogram: log(frequency) by time        1.2 ms <\n\n Memory estimate: 338.53 KiB, allocs estimate: 495.","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"To find out what the matrix representation of the FSWAP gate in the Majorana basis is, it is easiest to retrace what is happening inside instruct!(::MajoranaReg, ::AbstractMatrix, locs). You can use","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"@which instruct!(mreg, mat(FSWAP), (1,2))","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"instruct!(reg::MajoranaReg, gate::AbstractMatrix, locs) in FLOYao at ~/.julia/.../FLOYao/src/instruct.jl:49","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"to find the location of the corresponding code. Now let's copy-paste what we found there:","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"W = FLOYao.qubit2majoranaevolution(Matrix(fswap.content), fswap.locs)","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"4×4 Matrix{Float64}:\n -2.35415e-16  -4.12493e-16  -1.0           0.0\n  2.46746e-16  -5.5708e-16   -1.26504e-16  -1.0\n -1.0          -1.17708e-16   2.55988e-16  -2.38988e-16\n -1.85286e-16  -1.0           2.44068e-16   2.43374e-16","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"matlocs = 2*(fswap.locs[1]-1)+1:2(fswap.locs[end])","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"1:4","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"this matrix gets left-multiplied to the columns 1:4 in the last line of FLOYao.majorana_unsafe_apply!(::MajoranaReg, ::PutBlock). So we can instead implement the action of an FSWAP gate on a MajoranaReg directly as follows:","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"function YaoBlocks.unsafe_apply!(reg::MajoranaReg, b::PutBlock{2,2,FSWAPGate})\n    FLOYao.areconsecutive(b.locs) || throw(NonFLOException(\"FSWAP must act on consecutive qubits\"))\n    instruct!(reg, Val(:FSWAP), b.locs)\nend\n\nfunction Yao.instruct!(reg::MajoranaReg, ::Val{:FSWAP}, locs::Tuple)\n    i1, i2 = locs\n    row1, row2 = reg.state[2i1-1,:], reg.state[2i1,:]\n    row3, row4 = reg.state[2i2-1,:], reg.state[2i2,:]\n    reg.state[2i1-1,:] .=  .-row3\n    reg.state[2i1,:] .=  .-row4\n    reg.state[2i2-1,:] .=  .-row1\n    reg.state[2i2,:] .=  .-row2\n    return reg\nend","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"@benchmark apply!($mreg, $fswap)","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"BenchmarkTools.Trial: 10000 samples with 676 evaluations.\n Range (min … max):  183.416 ns …   4.023 μs  ┊ GC (min … max): 0.00% … 93.94%\n Time  (median):     198.760 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   224.080 ns ± 242.728 ns  ┊ GC (mean ± σ):  9.29% ±  8.02%\n\n  ▇ ▆ █▁▅ ▁                                                      \n  █▅███████▆▆▅▄▃▃▃▂▃▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂▂▂▁▁▁▂▂▁▁▁▂▂▂▁▂▁▂▂▂▂▂▂▂▂▂▂ ▃\n  183 ns           Histogram: frequency by time          362 ns <\n\n Memory estimate: 512 bytes, allocs estimate: 4.","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"Which is indeed a significant speed-up!","category":"page"}]
}
